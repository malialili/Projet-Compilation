import java_cup.runtime.*;
import java.util.Vector;
import java.io.*;
import java.lang.*;
import stree.*;

/*parser code {:
     

     public void syntax_error(Symbol cur_token)	{
	System.err.printf("Error!!!!!!!!!! at Line: %d Col: %d\n",cur_token.left, cur_token.right );
     }
:}*/
parser code {: 

    public void report_error(String message, Object info) {
        StringBuffer msg = new StringBuffer("error");
        if (info instanceof Symbol) {
            Symbol s = (Symbol) info;
            msg.append(" in line ");
            msg.append(s.left);
        }
        msg.append(": ");
        msg.append(message);
        System.err.println(msg);
    }

    public void report_error(String message) {
        StringBuffer msg = new StringBuffer("error");
        System.err.println(msg);
    }

    public void report_error(String message, int line) {
        StringBuffer msg = new StringBuffer("error in line ");
        msg.append(line);
        msg.append(": ");
        msg.append(message);
        System.err.println(msg);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
	throw new RuntimeException("Fatal Syntax Error");
    }

    public void syntax_error(Symbol cur_token) {
        StringBuffer msg = new StringBuffer("syntax error in ");
        msg.append((Integer.valueOf(cur_token.left + 1))+"("+cur_token.right+")");
        System.err.println(msg);
    }

    public void syntax_error(int line, int column) {
        StringBuffer msg = new StringBuffer("syntax error in ");
        msg.append((Integer.valueOf(line+1))+"("+column+")");
        System.err.println(msg);
    }

    :}

init with {:
    :}

terminal PROCEDURE, MAIN, LPAR, RPAR, SEMIC, PLUS, MINUS, MINUS_U, MULT, DIV, MOD, AFF, OF, TDOT, COMMA, LIST ;
terminal LCRO, RCRO, LT, GT, LE, GE, NOT, NE, DIFF, LBRACKET, RBRACKET, ARROW, DOT;
terminal EQ, AND, OR, LAND, LOR, VIR, PLUSS, MINUSS, CIRCUMFLEX;
terminal RETURN, STRUCTURE, IN, IF, THENELSE, WHILE, TRUE, FALSE, FUNCTION, TYPE, CLASS, NULL, FOREACH, REPEAT;
terminal String INTEGER, FLOAT, STRING_LITERAL;
terminal String ID;
terminal String STRING, BOOLEAN, CHARACTER;

/* The grammar */
non terminal  axiom;
non terminal SyntAbstr expr, stm, lhs, rhs, bloc, inst, instrs, decls, decl, stype, ctype, strc, var, pprog, exprl;
non terminal SyntAbstr fcts, fct, params, param, list, nbr;

precedence nonassoc THENELSE;
precedence nonassoc IF;
precedence left AND;
precedence left OR;
precedence left LT, GT, LE, GE, AFF, DIFF;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence left MINUS_U, NOT;

start with axiom;

axiom ::= 
	pprog:p 					{:	System.err.printf("***axiom \n"); RESULT = p;:}
	|decls:d  pprog: p 			{:	System.err.printf("***axiom \n"); RESULT = p;:}
	|fcts:f pprog:p				{:	System.err.printf("***axiom \n"); RESULT = p;:}
	|decls:d  pprog: p 	fcts:f	{:	System.err.printf("***axiom \n"); RESULT = f;:}
	|decls:d  fcts:f pprog:p	{:	System.err.printf("***axiom \n"); RESULT = p;:}
	;

pprog ::= 
	PROCEDURE MAIN  LPAR ID TDOT INTEGER COMMA ID TDOT LIST OF STRING RPAR bloc:b 	
	{: System.err.printf("*** pprog \n"); RESULT = b;:}
	;
fcts::=
	fcts:f fct:t 		{: System.err.printf("*** fcts \n"); RESULT = t; :}
	;	
fct ::=
	FUNCTION params:p bloc:b  		{: System.err.printf("*** FUNCTION \n"); RESULT = b; :}
	|PROCEDURE params:p bloc:b 		{: System.err.printf("*** PROCEDURE \n"); RESULT = b; :}
	;		
bloc ::= 
	LCRO instrs:i RCRO				{: System.err.printf("*** bloc \n"); RESULT = i; :}
	|LCRO decls:d instrs:i RCRO		{: System.err.printf("*** bloc \n"); RESULT = i; :}
	;
		
decls ::=
	  decls:s decl:d 			{:	System.err.printf("*** decls \n"); 	:}
	 |decl:d 					{:	System.err.printf("*** decls \n"); RESULT = d;:}
	 ;	 
decl ::= 
	ID:t TDOT stype:s SEMIC					{:	System.err.printf("*** decl \n"); RESULT = s;:}
	|ID:t TDOT ctype:c SEMIC				{:	System.err.printf("*** decl \n"); RESULT = c;:}
	|FUNCTION params:p TDOT stype:s SEMIC	{:	System.err.printf("*** decl \n"); RESULT = s;:}
	|PROCEDURE params:p SEMIC				{:	System.err.printf("*** decl \n"); RESULT = p;:}
	;
params ::=
	LPAR params:s COMMA param:p RPAR	{:	System.err.printf("*** params \n"); RESULT = s;:}
	|LPAR param:p RPAR					{:	System.err.printf("*** params \n"); RESULT = p;:}			
	;
param ::= 
	ID:t TDOT stype:s		{:	System.err.printf("*** param \n"); RESULT = s;:}
	|ID:t TDOT ctype:c 		{:	System.err.printf("*** param \n"); RESULT = c;:}
	;
stype ::=
	INTEGER			
	|FLOAT
	|STRING
	|CHARACTER
	|BOOLEAN
	;
ctype ::=
	LIST OF stype:t				{: System.err.printf("*** ctype \n"); RESULT = t; :}
	|LIST OF STRUCTURE strc:t	{: System.err.printf("*** ctype \n"); RESULT = t; :}
	|STRUCTURE strc:t			{: System.err.printf("*** ctype \n"); RESULT = t; :}
	;
strc ::=
	LCRO decls:d RCRO		{: System.err.printf("*** strc \n"); RESULT = d; :}
	;	
instrs ::=
	instrs:t inst:i  	{: System.err.printf("*** instrs \n" ); RESULT = i; :}
	|inst:i				{:	System.err.printf("*** inst \n"); RESULT = i; :}
	;
	
inst ::= 
	expr:t SEMIC		{: System.err.printf("*** inst \n"); RESULT = t; :} 
	|stm:t SEMIC		{: System.err.printf("*** stm\n"); RESULT = t; :}
	;

stm ::=
	lhs:e1 AFF rhs:e2					{: System.err.printf("*** stm\n"); RESULT = new SyntAbstr(e1, e2, EnumTag.AFF); :}
	|IF exprl:e stm:i1 THENELSE stm:i2  {: /* RESULT = new SyntAbstr(e, EnumTag.IF, new SyntAbstr(i1, i2, EnumTag.THENELSE));*/  :}
	|IF exprl:e stm:i  					{:  RESULT = new SyntAbstr(e, i, EnumTag.IF); :} /*%prec IF_WITHOUT_ELSE*/
	|WHILE exprl:e stm:i 				{:  RESULT =  new SyntAbstr(e, i, EnumTag.WHILE); :}
	|FOREACH ID:t IN list:l stm:i 		{:  RESULT = i;:}
	|REPEAT stm:t WHILE exprl:e 
	|RETURN ID:i
	|RETURN expr:e
	;
list ::=	
	 LBRACKET nbr:n RBRACKET	{: System.err.printf("*** LIST \n"); RESULT = n; :}
	 ;
nbr ::=
	INTEGER:str COMMA nbr:n		{: System.err.printf("*** nbr \n"); RESULT = n; :}
	|INTEGER:str				{: System.err.printf("*** integer \n"); :}
	;
rhs ::= 
	expr:e					{: System.err.printf("*** rhs\n");RESULT = e; :}
	;	
lhs ::=
	ID:t					{: System.err.printf("*** lhs\n"); RESULT = new SyntAbstr(EnumTag.ID, t);:}
	;
expr ::=
	expr:e1 PLUS expr:e2	{: System.err.printf("***expr	Line:%d  Col:%d \n", e1left, e1right); RESULT = new SyntAbstr(e1, e2, EnumTag.PLUS); :} 
	|expr:e1 MINUS expr:e2	{: System.err.printf("***expr  	Line:%d  Col:%d \n", e1left, e1right); RESULT = new SyntAbstr(e1, e2, EnumTag.MINUS); :} 
	|expr:e1 MULT expr:e2	{: System.err.printf("***expr   Line:%d  Col:%d \n", e1left, e1right); RESULT = new SyntAbstr(e1, e2, EnumTag.MULT); :} 
	|expr:e1 DIV expr:e2	{: System.err.printf("***expr   Line:%d  Col:%d \n", e1left, e1right); RESULT = new SyntAbstr(e1, e2, EnumTag.DIV); :} 
	|LPAR expr:e RPAR		{: System.err.printf("***expr   Line:%d  Col:%d \n", eleft, eright); RESULT = e; :} 
	|MINUS expr:e 			{: System.err.printf("***expr  	Line:%d  Col:%d \n", eleft, eright);	RESULT = new SyntAbstr(e, EnumTag.MINUS_U); :} %prec MINUS_U
	|INTEGER:str			{: System.err.printf("***expr 	Line:%d  Col:%d \n", strleft, strright); RESULT = new SyntAbstr(EnumTag.INTEGER, str); :}
	;

exprl ::=
	exprl:e1 AND exprl:e2	{: System.err.printf("***expr	Line:%d  Col:%d \n", e1left, e1right); RESULT = new SyntAbstr(e1, e2, EnumTag.AND); :} 
	|expr:e1 OR expr:e2		{: System.err.printf("***expr  	Line:%d  Col:%d \n", e1left, e1right); RESULT = new SyntAbstr(e1, e2, EnumTag.OR); :} 
	|NOT exprl:e			{: System.err.printf("***expr   Line:%d  Col:%d \n", eleft, eright); RESULT = new SyntAbstr(e, EnumTag.NOT); :}  %prec NOT
	|expr:e1 LAND expr:e2	{: System.err.printf("***expr   Line:%d  Col:%d \n", e1left, e1right); RESULT = new SyntAbstr(e1, e2, EnumTag.LAND); :} 
	|expr:e1 LOR expr:e2	{: System.err.printf("***expr   Line:%d  Col:%d \n", e1left, e1right); RESULT = new SyntAbstr(e1, e2, EnumTag.LOR); :} 
	|expr:e1 EQ expr:e2		{: System.err.printf("***expr   Line:%d  Col:%d \n", e1left, e1right); RESULT = new SyntAbstr(e1, e2, EnumTag.EQ); :} 
	|LPAR exprl:e RPAR		{: System.err.printf("***expr   Line:%d  Col:%d \n", eleft, eright); RESULT = e; :} 
	;
	
