import java_cup.runtime.*;
import java.util.Vector;
import java.io.*;
import java.lang.*;


parser code {:
     

     public void syntax_error(Symbol cur_token)	{
	System.err.printf("Error!!!!!!!!!! at Line: %d Col: %d\n",cur_token.left, cur_token.right );
     }
:}


terminal PROCEDURE, MAIN, LPAR, RPAR, SEMIC, PLUS, MINUS, MINUS_U, MULT, DIV, MOD, AFF, OF, TDOT, COMMA, LIST ;
terminal LCRO, RCRO, LT, GT, LE, GE, NOT, NE, DIFF, LBRACKET, RBRACKET, ARROW, DOT;
terminal EQ, AND, OR, LAND, LOR, VIR, PLUSS, MINUSS, CIRCUMFLEX;
terminal RETURN, STRUCTURE, IN, IF, THENELSE, WHILE, TRUE, FALSE, FUNCTION, TYPE, CLASS, NULL, FOREACH;
terminal String INTEGER, FLOAT, STRING_LITERAL;
terminal String ID;
terminal String STRING, BOOLEAN, CHARACTER;

/* The grammar */
non terminal SyntAbstr expr, axiom, stm, lhs, rhs, bloc, inst, instrs, decls, decl, vars, var, pprog;

precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence left MINUS_U;

start with axiom;

axiom ::= pprog:p 				{:	System.err.printf("***programme principal \n"); RESULT = p;	:}
		|decls:d  pprog: p 		{:	System.err.printf("***declaration + programme principal \n"); :}
		;

pprog ::= 
	PROCEDURE MAIN  LPAR ID TDOT INTEGER COMMA ID TDOT LIST OF STRING RPAR bloc:b 
	{:  /*  programme principal */ 
	 RESULT = b;
	:}
	;
bloc ::= 
	LCRO instrs:i RCRO
	{:  /*  bloc  */ 
	 RESULT = i;
	:}
	|LCRO decls : d STRING_LITERAL instrs:i RCRO
	;
	
decls ::=
	 decl:d  decls:s 			{:	System.err.printf("***plusieurs declaration \n"); 	:}
	 |decl:d 					{:	System.err.printf("*** une declaration \n"); RESULT = d;	:}
	 ;
	 
decl ::= vars:v TDOT INTEGER	{:	System.err.printf("***declaration \n"); RESULT = v;	:}
		|vars:v TDOT FLOAT		{:	System.err.printf("***declaration \n"); RESULT = v;	:}
		|vars:v TDOT STRING		{:	System.err.printf("***declaration \n"); RESULT = v;	:}
		|vars:v TDOT CHARACTER 	{:	System.err.printf("***declaration \n"); RESULT = v;	:}
		;

vars ::= ID COMMA vars:v 		{:	System.err.printf("***variables \n"); RESULT = v;	:}
		|ID						{:	System.err.printf("***variable\n");	:}
		;
		
		
instrs ::=
	inst: i STRING_LITERAL instrs : t	{: System.err.printf("***instrs \n" ); :}
	|inst : i			{:	System.err.printf("***inst \n"); RESULT = i;	:}
	;
inst ::= 
	expr:t SEMIC
	{: 
	 System.err.printf("***inst \n");
	 RESULT = t; 
	 :} 
	|stm:t SEMIC
	{: 
	 System.err.printf("***stm\n");
	 RESULT = t; 
	 :}
	;

stm ::=
	lhs:e1 AFF rhs:e2		{: System.err.printf("***stm\n"); RESULT = new SyntAbstr(e1, e2, EnumTag.AFF); :}
	 ;
	 
rhs::= expr:e				{: System.err.printf("***rhs\n");RESULT = e; :}
	;
	
lhs::=ID:t					{: System.err.printf("***lhs\n"); RESULT = new SyntAbstr(EnumTag.ID, t);:}
	;

expr ::=
	expr:e1 PLUS expr:e2
	{: 
	 System.err.printf("***expr\n");
	 RESULT = new SyntAbstr(e1, e2, EnumTag.PLUS); 
	 :} 
	| 

	expr:e1 MINUS expr:e2
	{: 
	 System.err.printf("***expr  Line:%d  Col:%d \n", e1left, e1right);
	 RESULT = new SyntAbstr(e1, e2, EnumTag.MINUS); 
	 :} 
	| 

	expr:e1 MULT expr:e2
	{:   
	 System.err.printf("***expr   Line:%d  Col:%d \n", e1left, e1right);
	 RESULT = new SyntAbstr(e1, e2, EnumTag.MULT); 
	 :} 
	| 

	expr:e1 DIV expr:e2
	{:   
	 System.err.printf("***expr   Line:%d  Col:%d \n", e1left, e1right);
	 RESULT = new SyntAbstr(e1, e2, EnumTag.DIV); 
	 :} 
	| 

	LPAR expr:e RPAR
	{: 
	 System.err.printf("***expr   Line:%d  Col:%d \n", eleft, eright);
	 RESULT = e; 
	 :} 
	| 

	MINUS expr:e 
	{: 
	 System.err.printf("***expr  Line:%d  Col:%d \n", eleft, eright);
	 RESULT = new SyntAbstr(e, EnumTag.MINUS_U); 
	 :} %prec MINUS_U
	| 

	INTEGER:str
	{: 
	    System.err.printf("***expr Line:%d  Col:%d \n", strleft, strright);
	    RESULT = new SyntAbstr(EnumTag.INTEGER, str); 
	    :}
	;